from kazoo.client import KazooClient
from kazoo.recipe.barrier import Barrier
from threading import Lock
import logging

controller_connection = 'node09:9066'
leader_node = '/leader'
participant_node = '/participant'
crash_node = '/crash'
barrier_node = '/leader-barrier'

class LeaderUpdate():
    def __init__(self):
        #Zookeeper watch on leader changes
        logging.basicConfig()
        self.zk = KazooClient(controller_connection)
        self.zk.start()
        self.zk.ensure_path(leader_node)
        self.zk.ensure_path(participant_node)
        self.zk.ensure_path(crash_node)
        self.zk.ensure_path(barrier_node)
        self.leader_barrier = Barrier(self.zk, barrier_node)
        self.lock = Lock()
        self.participants = []
        self.leader = ''
        self.leader_update_barrier = False
        @self.zk.DataWatch(leader_node)
        def leader_change(data,stat):
            with self.lock:
                self.leader = data
                print 'New Leader', data
                if self.leader_update_barrier:
                    self.leader_barrier.remove()
        #
        # @self.zk.ChildrenWatch(participant_node)
        # def quorum_change(children):
        #     with self.lock:
        #         for child in children:
        #             print child, self.zk.get(participant_node+'/'+child)
        #             self.participants.append(child)
        #         print self.participants
        #     return True
        #
        #
        # @self.zk.DataWatch(crash_node)
        # def empty_queues(data,event):
        #     with self.lock:
        #         self.participants = []
    def barrier(self, connection_string):
        print 'In barrier'
        if connection_string != self.get_leader():
            print connection_string,self.get_leader()
            return
        else:
            with self.lock:
                if not self.leader_update_barrier:
                    self.leader_update_barrier = True
                    print 'barier created'
                    self.leader_barrier.create()
        self.leader_barrier.wait()
        print 'Out of barrier'

    def get_leader(self):
        return self.leader

    def get_leader_tuple(self):
        leader = self.leader.split(':')
        return [(leader[1],leader[0])]

    def __del__(self):
        self.zk.stop()

